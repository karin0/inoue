// Block, with an optional scope.
code_block: [scope] "{" block_inner "}"

// LIMIT: `doc` must be before any statements in the block, to avoid ambiguity
// with 'branch', like in `a ? b : ;`.
// Use `*doc` for document expansion inside expressions/statements.
// Scopes can also be declared at the start of a block, before any document def/refs
// and statements, since you cannot write scopes before top-level "blocks" inside
// documents.
block_inner: [scope ";"] ((doc_def | doc_ref) (";" doc_ref)*)? stmt_list

// Statements, or statement-like modifiers.
scope: "@" [lvalue]
!doc_def: [iden] (":" | "↦")
doc_ref: ":" iden

?stmt_list: stmt? (";" stmt?)*

?stmt: swap
     | repl
     | expr
     | branch

// Variable names can be dynamically evaluated, except in 'expr' (where paren
// works as nested expr) and 'repl'.
?lvalue: iden | subscript | paren

// Other statements

// Expressions cannot be empty in conditions.
// Despite the grammar, when the end branch marker `!` is absent, the semantics
// only associate the first statement in the last branch, and the rest are executed
// unconditionally.
// `branch` is not treated as an expression due to ambiguity of `assign_or_equal`,
// Like in `a = $b ? c : d`.
branch: expr "?" stmt_list (":" stmt_list)? BRANCH_END?
BRANCH_END: "!"

swap: lvalue "^" lvalue

repl: iden ("|" repl_pair)+
repl_pair: [expr] "/" [expr]

// Expressions.
// 'lvalue' has different semantics inside 'expr'.
// A 'iden' here is treated as either a identifier or literal, but distinguishing
// them here breaks lexing, since we want to allow whitespaces inside naked literals.
// A 'paren' (i.e. nested 'expr') just replaces the outer one.
// The only dymamic name resolution allowed here is 'subscript'.
!expr: literal
     | unary_chain
     | code_block
     | compare
     | assign_or_equal
     | lvalue

subscript: lvalue "[" expr "]"

// Parentheses cannot be empty. Use '' for a empty value.
?paren: "(" expr ")"

// "Assignments" are technically expressions, but have different semantics as statements.
// We have to distinguish between assignments and equality conditions manually in
// the interpreter to avoid ambiguity of `=` in LALR.
assign_or_equal: lvalue ASSIGN_OP [expr]
ASSIGN_OP: "=" | ":=" | "?="

// Not arithmetic operators!
UNARY_OP: "+" | "-" | "*" | "$" | "::"

!unary: UNARY_OP lvalue
!unary_chain: unary+

// Even more equality! Expressions cannot be empty here either.
compare: expr _EQUAL expr

// Higher than ASSIGN_OP.
_EQUAL.10: "=="
?literal: ESCAPED_STRING  -> dq_lit
        | SQ_STRING       -> sq_lit

?iden: LITERAL

// Terminals.

// Exclude all punctuations except '_', '<', '>', '.', ',' from naked literals.
// U+21A6 (↦) is also excluded for a slick sub-doc definition.
LITERAL.-100: /[^\"#$%&'()*+\-\/:;=?!@[\\\]^`{|}~↦]+/

SQ_STRING: /'([^'\\]|\\.)*'/

%import common.ESCAPED_STRING
%import common.WS
%ignore WS

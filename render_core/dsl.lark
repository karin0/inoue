start: block_inner

// Block, with an optional scope.
code_block: [SCOPE_OP [dyn_iden]] "{" block_inner "}"
SCOPE_OP: "@"

// LIMIT: `doc` must be before any statements in the block, to avoid ambiguity
// with 'branch', like in `a ? b : ;`.
// Use `*doc` for document expansion inside expressions/statements.
// Scopes can also be declared at the start of a block, before any document def/refs
// and statements.
!block_inner: [SCOPE_OP [dyn_iden] ";"] [(doc_def | doc_ref) (";" doc_ref)*] stmt_list

// Statements... or document definitions/references.

!doc_def: iden ":"
!doc_ref: ":" iden

stmt_list: [stmt] [";" stmt_list]

?stmt: swap
     | repl
     | expr
     | branch

// Variable names can be dynamically evaluated, except in 'expr' (permissive)
// and 'repl'.
?dyn_iden: iden | paren

// Other statements

// Expressions cannot be empty in conditions.
// Despite the grammar, when the end branch marker `!` is absent, the semantics
// only associate the first statement in the last branch, and the rest are executed
// unconditionally.
// `branch` is not treated as an expression due to ambiguity of `assign_or_equal`,
// Like in `a = $b ? c : d`.
branch: expr "?" stmt_list [":" stmt_list] [BRANCH_END]
BRANCH_END: "!"

swap: dyn_iden "^" dyn_iden

repl: iden ("|" repl_pair)+
repl_pair: [expr] "/" [expr]

// Expressions.
!expr: literal
     | unary_chain
     | code_block
     | compare
     | assign_or_equal
     | paren

// Parentheses cannot be empty. Use '' for a empty value.
?paren: "(" expr ")"

// "Assignments" are technically expressions, but have different semantics as statements.
// We have to distinguish between assignments and equality conditions manually in
// the interpreter to avoid ambiguity of `=` in LALR.
assign_or_equal: dyn_iden ASSIGN_OP [expr]
ASSIGN_OP: "=" | ":=" | "?="

// Not arithmetic operators!
UNARY_OP: "+" | "-" | "*" | "$" | "::"

!unary: UNARY_OP dyn_iden
!unary_chain: unary+

// Even more equality! Expressions cannot be empty here either.
compare: expr _EQUAL expr

// Higher than ASSIGN_OP.
_EQUAL.10: "=="

// A 'naked_lit' is actually either a identifier or literal, but distinguishing
// them here breaks lexing, since we want to allow whitespaces inside naked literals.
?literal: ESCAPED_STRING  -> dq_lit
        | SQ_STRING       -> sq_lit
        | iden            -> naked_lit

?iden: LITERAL

// Terminals.

// Exclude all punctuations except '_', '<', '>', '.' from naked literals.
// U+21A6 (↦) is also excluded for a slick sub-doc definition.
LITERAL.-100: /[^\"#$%&'()*+\-,\/:;=?!@[\\\]^`{|}~↦]+/

SQ_STRING: /'([^'\\]|\\.)*'/

%import common.ESCAPED_STRING
%import common.WS
%ignore WS

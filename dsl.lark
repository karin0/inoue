start: block_inner

// Block

?code_block: "{" block_inner "}"

// LIMIT: `doc` must be before any statements in the block.
// Use `*doc` for document expansion inside statements.
!block_inner: [(doc_def | doc_ref) (";" doc_ref)*] stmt_list

// Statements... or document definitions/references.

!doc_def: iden ":"
!doc_ref: ":" iden

stmt_list: stmt? [";" stmt_list]

?stmt: swap
     | repl
     | expr
     | branch

// Assignments

assign: iden ASSIGN_OP [expr]

ASSIGN_OP: "=" | ":=" | "?="

// Other statements

// Expressions cannot be empty in conditions.
// We have to distinguish between assignments and equality conditions in the interpreter
// to avoid ambiguity of `=` in LALR.
branch: expr "?" stmt_list [":" stmt_list]

swap: iden "^" iden

repl: iden ("|" repl_pair)+
repl_pair: [expr] "/" [expr]

// Expressions

!expr: literal
     | unary_chain
     | code_block
     | compare
     | assign
     | paren

?paren: "(" [expr] ")"

UNARY_OP: "+" | "-" | "*" | "$"
unary: UNARY_OP iden
!unary_chain: unary+

// Even more equality! Expressions cannot be empty here either.
compare: expr _EQUAL expr

// Higher than ASSIGN_OP.
_EQUAL.10: "=="

?literal: ESCAPED_STRING  -> dq_lit
        | SQ_STRING       -> sq_lit
        | iden            -> naked_lit  // Actually either var or literal, but that breaks LALR's parsing.

?iden: LITERAL

// Terminals

// Exclude all punctuations except '_', '<', '>', '!' from naked literals.
LITERAL.-100: /[^\"#$%&'()*+\-,.\/:;=?@[\\\]^`{|}~]+/

SQ_STRING: /'([^'\\]|\\.)*'/

%import common.ESCAPED_STRING
%import common.WS
%ignore WS

start: block_inner

// Block

?code_block: "{" block_inner "}"

// LIMIT: doc_def must be the first statement in the block, and cannot be conditional.
!block_inner: doc_def | ([doc_def ";"] stmt_list)

// Statements... or document definition.

!doc_def: iden ":"

stmt_list: stmt? [";" stmt_list]

!stmt: unary_chain
     | swap
     | repl
     | expr
     | branch

// Assignments

assign: iden ASSIGN_OP expr?

ASSIGN_OP: "=" | ":=" | "?="

// Other statements

// Expressions cannot be empty in conditions.
// We have to distinguish between assignments and equality conditions in the interpreter
// to avoid ambiguity of `=` in LALR.
branch: expr "?" stmt_list [":" stmt_list]

swap: iden "^" iden

flag_override: "+" iden  -> flag_set
             | "/" iden  -> flag_unset

unary_chain: flag_override+ deref?

repl: iden ("|" repl_pair)+
repl_pair: expr? "/" expr?

// Expressions

!expr: literal
     | deref
     | code_block
     | compare
     | assign
     | paren

?paren: "(" expr ")"

// Even more equality!
compare: expr _EQUAL expr

// Higher than ASSIGN_OP.
_EQUAL.10: "=="

?literal: ESCAPED_STRING  -> dq_lit
        | SQ_STRING       -> sq_lit
        | iden            -> naked_lit  // Actually either var or literal, but that breaks LALR's parsing.

?iden: LITERAL

deref: DEREF_OP iden
DEREF_OP.-100: ":" | "*" | "$"

// Terminals

// Exclude all punctuations except '_', '-', '<', '>', '!' from naked literals.
LITERAL.-100: /[^\"#$%&'()*+,.\/:;=?@[\\\]^`{|}~]+/

SQ_STRING: /'([^'\\]|\\.)*'/

%import common.ESCAPED_STRING
%import common.WS
%ignore WS

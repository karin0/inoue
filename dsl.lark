start: block_inner

// Block

?code_block: "{" block_inner "}"

// LIMIT: doc_def must be the first statement in the block, and cannot be conditional.
!block_inner: doc_def | ([doc_def ";"] stmt_list)

// Statements... or document definition.

!doc_def: iden ":"

stmt_list: stmt? [";" stmt_list]

!stmt: unary_chain
     | swap
     | repl
     | branch_or_assign_or_expr

// Assignments

assign_part: iden "=" (assign_part | expr?)

assign: iden ("=" | ASSIGN_OP) (assign_part | expr?)

ASSIGN_OP: ":=" | "?="

// Other statements

// Expressions cannot be empty in conditions.
// We have to distinguish between assignments and equality conditions in the interpreter
// to avoid ambiguity of `=` in LALR.
branch_or_assign_or_expr: (expr | assign) ["?" stmt_list [":" stmt_list]]

swap: iden "^" iden

flag_override: "+" iden  -> flag_set
             | "/" iden  -> flag_unset

unary_chain: flag_override+ deref?

repl: iden ("|" repl_pair)+
repl_pair: expr? "/" expr?

// Expressions

!expr: literal
     | deref
     | code_block
     | compare

// Even more equality!
compare: expr "==" expr

?literal: ESCAPED_STRING  -> dq_lit
        | SQ_STRING       -> sq_lit
        | iden            -> naked_lit  // Actually either var or literal, but that breaks LALR's parsing.

?iden: LITERAL

deref: DEREF_OP iden
DEREF_OP.-100: ":" | "*" | "$"

// Terminals

// Exclude all punctuations except '_', '-', '<', '>', '!' from naked literals.
LITERAL.-100: /[^\"#$%&'()*+,.\/:;=?@[\\\]^`{|}~]+/

SQ_STRING: /'([^'\\]|\\.)*'/

%import common.ESCAPED_STRING
%import common.WS
%ignore WS
